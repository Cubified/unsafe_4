#!/usr/bin/python3

# gen_bootstrap.py: given opcodes as ascii, copies bytes to 0x92000000 before
#   handing off execution to the copied code
#
# Intended to place the DOL loader into a relatively non-volatile location
#   in memory to avoid corruption when new blocks are malloced by other
#   functions

import sys

if len(sys.argv) < 2:
    print('Usage: gen_bootstrap.py [file with input opcodes as ascii]')
    exit(1)

infile = open(sys.argv[1], 'r')
outfile = open(sys.path[0]+'/bootstrap.S', 'w')

ascii = infile.read()

if (len(ascii)-1) % 4 > 0:
    print('Error: length of opcodes file must be divisible by 4 (all ppc opcodes are 8 bytes)')
    infile.close()
    outfile.close()
    exit(2)

# .global _start
# .text
# _start:
#   lis 29, 0x91ff     ; Current destination for copied code (4 bytes behind 0x92000000 because stwu advances automatically)
#   ori 29, 29, 0xfffc ; ^ (lower 16 bits)
#   lis 31, 0x9200     ; Entry point which skips _start prologue
#   ori 31, 31, 0x0000 ; ^ (lower 16 bits)
#   lis  1,  0x8080    ; Set up stack frame
#   li   0,  0         ; ^
#   stwu 0, -64(1)     ; ^
outfile.write('.global _start\n.text\n_start:\nlis 29, 0x91ff\nori 29, 29, 0xfffc\nlis 31, 0x9200\nori 31, 31, 0x0000\nlis 1, 0x8080\nli 0, 0\nstwu 0, -64(1)\n\n')

# lis  28, 0xnnnn     ; Store the upper 16 bits of an opcode in register 28
# ori  28, 28, 0xnnnn ; Append the lower 16 bits of an opcode into register 28
# stwu 28, 4(29)      ; Store the opcode into memory, then move the destination pointer forward one opcode
for ind in range(0, len(ascii)-1, 8):
    outfile.write('lis 28, 0x'+ascii[ind:ind+4]+'\nori 28, 28, 0x'+ascii[ind+4:ind+8]+'\nstwu 28, 4(29)\n')

# mtspr 9, 31 ; Move the contents of register 31 (0x92000000) into the count register (special-purpose register #9)
# mtlr 31     ; Move the contents of register 31 into the link register
# blr         ; Hand off execution to the newly-copied code
outfile.write('\nmtspr 9, 31\nmtlr 31\nblr\n')

infile.close()
outfile.close()
